(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{501:function(s,a,n){"use strict";n.r(a);var t=n(0),e=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h3",{attrs:{id:"一、redis知识系统观"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、redis知识系统观"}},[s._v("#")]),s._v(" 一、Redis知识系统观")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("Redis从应用维度有：缓存使用、集群运用、数据结构的巧妙使用；")])]),s._v(" "),a("li",[a("p",[s._v("Redis从系统维度有：可以归类为三高")]),s._v(" "),a("blockquote",[a("ol",[a("li",[s._v("高性能：线程模型、网络 IO 模型、数据结构、持久化机制；")]),s._v(" "),a("li",[s._v("高可用：主从复制、哨兵集群；")]),s._v(" "),a("li",[s._v("高拓展：Cluster 分片集群")])])])]),s._v(" "),a("li",[a("p",[s._v("Redis 为了高性能，从各方各面都进行了优化。")]),s._v(" "),a("blockquote",[a("p",[s._v("基准测试：横轴是连接数，纵轴是 QPS\n"),a("img",{attrs:{src:"/redis/redis%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95.png",alt:"image.png"}})])])])]),s._v(" "),a("h3",{attrs:{id:"二、redis为什么这么快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、redis为什么这么快"}},[s._v("#")]),s._v(" 二、Redis为什么这么快？")]),s._v(" "),a("blockquote",[a("ol",[a("li",[s._v("Redis是基于内存操作，需要的时候需要我们手动持久化到硬盘中")]),s._v(" "),a("li",[s._v("Redis高效数据结构，对数据的操作也比较简单")]),s._v(" "),a("li",[s._v("Redis是单线程模型，从而避开了多线程中上下文频繁切换的操作")]),s._v(" "),a("li",[s._v("使用多路I/O复用模型，非阻塞I/O")]),s._v(" "),a("li",[s._v("使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求\n"),a("img",{attrs:{src:"/redis/5%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png",alt:"image.png"}})])])]),s._v(" "),a("h3",{attrs:{id:"_1-1、基于内存的操作实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、基于内存的操作实现"}},[s._v("#")]),s._v(" 1.1、基于内存的操作实现")]),s._v(" "),a("blockquote",[a("p",[a("code",[s._v("Redis 是基于内存的数据库，不论读写操作都是在内存上完成的，完全吊打磁盘数据库的速度。Redis之所以可以使用单线程来处理，其中的一个原因是，内存操作对资源损耗较小，保证了处理的高效性。")])])]),s._v(" "),a("h3",{attrs:{id:"_1-2、高效的数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、高效的数据结构"}},[s._v("#")]),s._v(" 1.2、高效的数据结构")]),s._v(" "),a("p",[a("strong",[s._v("string字符串对象")]),s._v(" "),a("img",{attrs:{src:"/redis/%E5%AD%97%E7%AC%A6%E4%B8%B2.awebp",alt:"image.awebp"}})]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("//简单动态字符串结构体\nstruct sdshdr {\n    // 字符串长度\n    int len;\n    // buf数组中未使用的字节数\n    int free;\n    // 字节数组，用于保存字符串\n    char buf[];\n}; \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[a("strong",[s._v("hash对象")])]),s._v(" "),a("ul",[a("li",[s._v("哈希对象的编码可以是ziplist或者hashtable。\n如果此时使用ziplist编码，那么该Hash对象在内存中的结构如下：\n"),a("img",{attrs:{src:"/redis/hash%E4%BD%BF%E7%94%A8zipList.awebp",alt:"image.awebp"}})])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("//Redis使用的哈希表由dictht结构定义：\ntypedef struct dictht{\n    // 哈希表数组\n    dictEntry **table;\n\n    // 哈希表大小\n    unsigned long size;\n\n    // 哈希表大小掩码，用于计算索引值\n    // 总是等于 size-1\n    unsigned long sizemask;\n\n    // 该哈希表已有节点数量\n    unsigned long used;\n} **dictht**\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("ul",[a("li",[s._v("Hash对象在内存中的结构如下：")])]),s._v(" "),a("blockquote",[a("ol",[a("li",[s._v("对象指针指向dict字典 :\nht是大小为2，且每个元素都指向dictht哈希表。一般情况下，字典只会使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。rehashidx记录了rehash的进度，如果目前没有进行rehash，值为-1。")])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("typedef struct dict {\n\n    // 类型特定函数\n    dictType *type;\n\n    // 私有数据\n    void *privdata;\n\n    // 哈希表\n    dictht ht[2];\n\n    //rehash索引\n    // 当rehash不在进行时，值为-1\n    int rehashidx;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("blockquote",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("字典使用dictht hash表")])]),s._v(" "),a("ul",[a("li",[s._v("table属性是一个数组，数组中的每个元素都是一个指向dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，即table数组的大小。used属性记录了哈希表目前已有节点数量。sizemask总是等于size-1，这个值主要用于数组索引。")])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("typedef struct dictht{\n    // 哈希表数组\n    dictEntry **table;\n\n    // 哈希表大小\n    unsigned long size;\n\n    // 哈希表大小掩码，用于计算索引值\n    // 总是等于 size-1\n    unsigned long sizemask;\n\n    // 该哈希表已有节点数量\n    unsigned long used;\n} dictht\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("blockquote",[a("ol",{attrs:{start:"3"}},[a("li",[s._v("哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对")])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("typedef struct dictEntry {\n    // 键\n    void *key;\n\n    // 值\n    union {\n        void *val;\n        unit64_t u64;\n        nit64_t s64;\n    } v;\n\n    // 指向下一个哈希表节点，形成链表\n    struct dictEntry *next;\n} dictEntry;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[a("img",{attrs:{src:"/redis/hash%E5%AF%B9%E5%BA%94%E7%9A%84hash%E8%A1%A8%E7%BB%93%E6%9E%84.awebp",alt:"image.awebp"}})]),s._v(" "),a("p",[a("strong",[s._v("ziplist压缩列表")]),s._v(" "),a("img",{attrs:{src:"/redis/ziplist%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.awebp",alt:"image.awebp"}})]),s._v(" "),a("p",[a("strong",[s._v("跳跃表skiplist")])]),s._v(" "),a("blockquote",[a("p",[s._v("是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。\n"),a("img",{attrs:{src:"/redis/skiplist.awebp",alt:"image.awebp"}})])]),s._v(" "),a("h3",{attrs:{id:"_1-3、单线程模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3、单线程模型"}},[s._v("#")]),s._v(" 1.3、单线程模型")]),s._v(" "),a("blockquote",[a("p",[s._v("我们要明确的是：Redis 的单线程指的是 Redis 的网络 IO 以及键值对指令读写是由一个线程来执行的。 对于 Redis 的持久化、集群数据同步、异步删除等都是其他线程执行。")])]),s._v(" "),a("ul",[a("li",[s._v("单线程是否没有充分利用 CPU 资源呢？")])]),s._v(" "),a("blockquote",[a("p",[s._v("官方答案：因为 Redis 是基于内存的操作，使用Redis时，几乎不存在CPU成为瓶颈的情况， Redis主要受限于服务器内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理10万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。")])]),s._v(" "),a("ul",[a("li",[s._v("IO多路复用模型和性能优良的事件驱动")])]),s._v(" "),a("blockquote",[a("p",[s._v("Redis 采用 I/O 多路复用技术，并发处理连接。采用了 epoll + 自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 IO 上浪费一点时间。\n"),a("img",{attrs:{src:"/redis/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png",alt:"image.png"}})])]),s._v(" "),a("h3",{attrs:{id:"三、redis-唯快不破的原理总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、redis-唯快不破的原理总结"}},[s._v("#")]),s._v(" 三、Redis 唯快不破的原理总结")]),s._v(" "),a("ul",[a("li",[s._v("纯内存操作：一般都是简单的存取操作，线程占用的时间很少，时间的花费主要集中在 IO 上，所以读取速度快。")]),s._v(" "),a("li",[s._v("采用单线程模型：保证了每个操作的原子性，也减少了线程的上下文切换和竞争。")]),s._v(" "),a("li",[s._v("Redis 使用IO多路复用模型：非阻塞 IO，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，Redis 采用自己实现的事件分离器，效率比较高。")]),s._v(" "),a("li",[s._v("Redis高效数据结构，对数据的操作也比较简单：\n"),a("ul",[a("li",[s._v("（1）整个 Redis 就是一个全局哈希表：他的时间复杂度是 O(1)，而且为了防止哈希冲突导致链表过长，Redis 会执行 rehash 操作，扩充 哈希桶数量，减少哈希冲突。并且防止一次性重新映射数据过大导致线程阻塞，采用 渐进式 rehash。巧妙的将一次性拷贝分摊到多次请求过程后总，避免阻塞。")]),s._v(" "),a("li",[s._v("（2）Redis 全程使用 hash 结构：读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。可以根据实际存储的数据类型选择不同编码。")])])])]),s._v(" "),a("h3",{attrs:{id:"结束语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结束语"}},[s._v("#")]),s._v(" 结束语")])])}),[],!1,null,null,null);a.default=e.exports}}]);